source "$HOME/.gitrc"

alias vcrc='vim ~/.commonrc'
alias vgrc='vim ~/.gitrc'
alias vvrc='vim ~/.vimrc'


HISTSIZE=999999999 # the number of commands that are loaded into memory from the history file
HISTFILESIZE=999999999 # the number of commands that are stored in the history file (when the shell ends)
SAVEHIST=$HISTSIZE

export HISTCONTROL=ignoredups # This ignores duplicate commands in .bash_history

# colours for the terminal to differentiate between files and directories
export CLICOLOR=1
export LSCOLORS=GxFxCxDxBxegedabagaced

#alias vim="/bin/nvim"
alias cl="clear && printf '\e[3J'"
set -o vi # enables vi mode in terminal

if [ "$MANUALLY_SOURCING_RC" != "true" ]; then
    ## Open new terminal in same directory as last terminal:
    if [ -f ~/.last_dir ]; then
        cd "`cat ~/.last_dir`"
    fi
fi

alias cdd='cd $(fd --type directory | fzf || echo .)' # The "|| echo ." makes it so if we cancel the fzf command, we don't change to a diff directory
alias xclip='xclip -selection clipboard'

# python aliases
alias create-venv='python -m venv ./venv'
alias sv='source venv/bin/activate; echo activated venv on $(which python) $(python --version);'
alias svv='source .venv/bin/activate; echo activated venv on $(which python) $(python --version);'

# Quality of Life
alias rg="rg --color=always"
# qf stands for quick find
alias qf='rg --column --line-number --no-heading --color=always --smart-case . | fzf --ansi --height=50% --layout=reverse'
alias killport='function _killport() { lsof -i :$1 | awk '\''NR > 1 {print $2}'\'' | xargs -I {} kill -9 {}; };_killport'

alias stopdocker='docker stop $(docker ps -a -q)'
alias rmdocker='docker rm $(docker ps -a -q)'

function select_conda_env() {
    # Get the list of conda environments
    envs=$(conda info --envs | awk 'NR>2 {print $1}')

    # Use fzf to select an environment
    selected_env=$(echo "$envs" | fzf --prompt="Select a conda environment: ")

    # Check if a valid environment was selected
    if [[ -n "$selected_env" ]]; then
        conda activate "$selected_env"
    else
        echo "No environment selected."
    fi
}

export TERM=xterm-256color # for kitty terminal

# so when I'm in a docker container pytest will use the number of cpus allocated for that container
# https://chatgpt.com/share/68c9c5aa-58ec-800e-a3cc-8d3619345f7e
_pytest_auto_workers() {
  local n="" quota period cpus

  # cgroup v2: /sys/fs/cgroup/cpu.max has "<quota> <period>" or "max <period>"
  if [ -r /sys/fs/cgroup/cpu.max ]; then
    read -r quota period < /sys/fs/cgroup/cpu.max
    if [ "$quota" != "max" ] && [ -n "$quota" ] && [ -n "$period" ] && [ "$period" -gt 0 ]; then
      n=$(( quota / period ))
    fi

  # cgroup v1: quota/period files
  elif [ -r /sys/fs/cgroup/cpu/cpu.cfs_quota_us ] && [ -r /sys/fs/cgroup/cpu/cpu.cfs_period_us ]; then
    quota=$(cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us 2>/dev/null)
    period=$(cat /sys/fs/cgroup/cpu/cpu.cfs_period_us 2>/dev/null)
    if [ -n "$quota" ] && [ "$quota" -gt 0 ] && [ -n "$period" ] && [ "$period" -gt 0 ]; then
      n=$(( quota / period ))
    fi
  fi

  # Host CPU count (Linux/macOS)
  if command -v nproc >/dev/null 2>&1; then
    cpus=$(nproc)
  else
    cpus=$(sysctl -n hw.ncpu 2>/dev/null || echo 1)
  fi

  # Fallbacks and sanity caps
  if [ -z "$n" ] || [ "$n" -lt 1 ]; then
    n=$cpus
  fi
  if [ "$n" -gt "$cpus" ]; then
    n=$cpus
  fi

  echo "$n"
}

export PYTEST_XDIST_AUTO_NUM_WORKERS="$(_pytest_auto_workers)"
