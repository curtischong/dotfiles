alias gpl='git pull'
alias gp='git push && echo "git push"'
alias gpf='git push --force-with-lease && echo "git push --force-with-lease"'
alias gps='git push --set-upstream origin "$(git branch --show-current)"' # use this when you push a new branch and git says: "fatal: The current branch kaniko-builds has no upstream branch."
alias gco='git checkout'
alias gcom='git checkout main || git checkout master'
alias gcob='git checkout -b'
alias gcm='git commit -m'
alias gcmn='git commit --no-verify -m'
alias gca='git commit --amend --date=now' # this is like gc, but we want to edit the commit message
alias gc='gca --no-edit && echo "git commit --amend --no-edit --date=now"'
alias gf='git fetch origin && echo "fetched origin"'
alias grm='gf && git rebase origin/main || git rebase origin/master'
alias gr='git rebase --onto'
alias grc='git rebase --continue'
alias gra='git rebase --abort'
alias grl='git reflog'
alias gl='git log'
alias gs='git status'
alias ga='git add'
alias gaa='git add --all'
alias gd='git diff'
alias gds='git diff --staged'
alias gb='git branch'
alias gsc='scommit'
alias gsca='scommit -a'

# TODO: use rg over grep?
# alias rmoldbranches='git branch --merged | grep -v \* | xargs git branch -D'
# alias rmoldbranches='git branch --merged main | grep -v "^\* main" | xargs -n 1 -r git branch -d'
# alias rmoldbranches="git branch --merged | grep -v '\*\|master\|main\|develop' | xargs -n 1 git branch -d"
alias rmoldbranches='git fetch --prune && git branch --merged | egrep -v "(^\*|master|main|dev)" | xargs git branch -d'
alias nukebranches='rmoldbranches && sh ~/nuke-local-branches.sh'

# Define the alias to rename the Git branch and remote
alias rename-branch='rename_branch'

# Function to rename the current branch and its remote counterpart
rename_branch() {
    if [ "$#" -ne 1 ]; then
        echo "Usage: git-rename-branch NEW_BRANCH_NAME"
        return 1
    fi

    local new_branch="$1"
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    if [ "$current_branch" = "HEAD" ]; then
        echo "Cannot rename detached HEAD. Switch to a branch first."
        return 1
    fi

    # Rename the local branch
    git branch -m "$new_branch"

    git push --set-upstream origin "$new_branch"
    git push origin --delete "$current_branch"
}

# https://chatgpt.com/share/68c05a81-5dfc-800e-a987-e2db00ea81f2
# https://chatgpt.com/share/68c05a81-5dfc-800e-a987-e2db00ea81f2
# gad: Pop (apply latest batch) via 3-way merge, then DELETE the patch (LIFO).
#      Options:
#        gad                 -> pop latest batch
#        gad --keep          -> apply latest but keep patch
#        gad --patch FILE    -> apply specific patch file (kept unless --keep)
#        gad all / --all     -> pop ALL batches newest→oldest
alias gad='f(){ \
  DIFF_DIR="${GIT_DIFF_DIR:-.git/file-diffs}"; \
  git rev-parse --show-toplevel >/dev/null 2>&1 || { echo "Not a git repo."; return 1; }; \
  [ -d "$DIFF_DIR" ] || { echo "No stored diffs ($DIFF_DIR)."; return 1; }; \
  git diff --cached --quiet || { echo "Refusing: you have STAGED changes. Unstage or stash first."; return 1; }; \
  KEEP=0; MODE=single; PATCH=""; \
  case "$1" in \
    --keep) KEEP=1; shift ;; \
  esac; \
  case "$1" in \
    all|--all) MODE=all; shift ;; \
    --patch) PATCH="$2"; shift 2 ;; \
  esac; \
  apply_patch(){ \
    local p="$1"; \
    echo "Applying (3-way): $p"; \
    if git apply -3 --whitespace=nowarn "$p"; then \
      echo "  Applied cleanly."; \
    else \
      echo "  Applied with conflicts (markers written)."; \
    fi; \
    if [ $KEEP -eq 0 ]; then \
      rm -f "$p" "${p%.patch}.list"; \
      echo "  Popped: $p"; \
    else \
      echo "  Kept: $p"; \
    fi; \
  }; \
  shopt -s nullglob; \
  if [ -n "$PATCH" ]; then \
    [ -f "$PATCH" ] || { echo "Patch not found: $PATCH"; return 1; }; \
    apply_patch "$PATCH"; \
  elif [ "$MODE" = all ]; then \
    patches=( "$DIFF_DIR"/*.patch ); \
    [ ${#patches[@]} -gt 0 ] || { echo "No patches to apply."; return 1; }; \
    mapfile -d "" -t sorted < <(printf "%s\0" "${patches[@]}" | sort -z); \
    # newest→oldest (stack pop order)
    for ((i=${#sorted[@]}-1; i>=0; i--)); do \
      apply_patch "${sorted[$i]}"; \
    done; \
  else \
    patches=( "$DIFF_DIR"/*.patch ); \
    [ ${#patches[@]} -gt 0 ] || { echo "No patches to apply."; return 1; }; \
    mapfile -d "" -t sorted < <(printf "%s\0" "${patches[@]}" | sort -z); \
    latest="${sorted[-1]}"; \
    apply_patch "$latest"; \
  fi; \
  # housekeeping pointer
  remaining=( "$DIFF_DIR"/*.patch ); \
  if [ ${#remaining[@]} -eq 0 ]; then \
    rm -f "$DIFF_DIR/.latest_patch"; \
  else \
    mapfile -d "" -t remsrt < <(printf "%s\0" "${remaining[@]}" | sort -z); \
    echo "${remsrt[-1]}" > "$DIFF_DIR/.latest_patch"; \
  fi; \
}; f'

alias gsd='f(){ \
  BASE="${GIT_BASE:-main}"; \
  DIFF_DIR="${GIT_DIFF_DIR:-.git/file-diffs}"; \
  mkdir -p "$DIFF_DIR" || return 1; \
  git rev-parse --show-toplevel >/dev/null 2>&1 || { echo "Not a git repo."; return 1; }; \
  # 1) Block if anything is staged
  git diff --cached --quiet || { echo "Refusing: you have STAGED changes. Unstage or stash first."; return 1; }; \
  # 2) Block if there are UNSTAGED changes outside the files we will save
  if [ $# -eq 0 ]; then echo "Usage: gsd <file> [file ...]"; return 1; fi; \
  mapfile -t dirty_unstaged < <(git diff --name-only); \
  if [ ${#dirty_unstaged[@]} -gt 0 ]; then \
    others=(); \
    for p in "${dirty_unstaged[@]}"; do \
      keep=0; for t in "$@"; do [ "$p" = "$t" ] && { keep=1; break; }; done; \
      [ $keep -eq 0 ] && others+=("$p"); \
    done; \
    if [ ${#others[@]} -gt 0 ]; then \
      echo "Refusing: UNSTAGED changes outside target files:"; \
      printf "  %s\n" "${others[@]}"; \
      echo "Stash/commit/clean them or include them in the gsd command."; \
      return 1; \
    fi; \
  fi; \
  # proceed (only target files may be dirty)
  ts="$(date +%Y%m%d-%H%M%S)"; \
  branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo unknown)"; \
  files=(); \
  for f in "$@"; do \
    if git diff --quiet "$BASE" -- "$f"; then echo "No changes vs $BASE: $f"; else files+=("$f"); fi; \
  done; \
  [ ${#files[@]} -gt 0 ] || { echo "Nothing to save."; return 0; }; \
  patch="$DIFF_DIR/${ts}__${branch}.patch"; \
  list="$DIFF_DIR/${ts}__${branch}.list"; \
  git diff --no-ext-diff --binary --full-index "$BASE" -- "${files[@]}" > "$patch" || { echo "Failed to create patch."; rm -f "$patch"; return 1; }; \
  printf "%s\n" "${files[@]}" > "$list"; \
  git restore --staged --worktree -s "$BASE" -- "${files[@]}" || { echo "Restore to $BASE failed."; return 1; }; \
  echo "Saved: $patch"; \
  echo "Reverted to $BASE (index+worktree) for listed files."; \
}; f'
